{"ast":null,"code":"/* globals setImmediate, clearImmediate, setTimeout, clearTimeout */\n\n/* eslint-disable no-unused-vars, no-prototype-builtins, no-use-before-define, no-unused-labels, no-param-reassign */\n\"use strict\";\n\nvar Aff = function () {\n  // A unique value for empty.\n  var EMPTY = {};\n  /*\n   An awkward approximation. We elide evidence we would otherwise need in PS for\n  efficiency sake.\n   data Aff eff a\n    = Pure a\n    | Throw Error\n    | Catch (Aff eff a) (Error -> Aff eff a)\n    | Sync (Eff eff a)\n    | Async ((Either Error a -> Eff eff Unit) -> Eff eff (Canceler eff))\n    | forall b. Bind (Aff eff b) (b -> Aff eff a)\n    | forall b. Bracket (Aff eff b) (BracketConditions eff b) (b -> Aff eff a)\n    | forall b. Fork Boolean (Aff eff b) ?(Fiber eff b -> a)\n    | Sequential (ParAff aff a)\n   */\n\n  var PURE = \"Pure\";\n  var THROW = \"Throw\";\n  var CATCH = \"Catch\";\n  var SYNC = \"Sync\";\n  var ASYNC = \"Async\";\n  var BIND = \"Bind\";\n  var BRACKET = \"Bracket\";\n  var FORK = \"Fork\";\n  var SEQ = \"Sequential\";\n  /*\n   data ParAff eff a\n    = forall b. Map (b -> a) (ParAff eff b)\n    | forall b. Apply (ParAff eff (b -> a)) (ParAff eff b)\n    | Alt (ParAff eff a) (ParAff eff a)\n    | ?Par (Aff eff a)\n   */\n\n  var MAP = \"Map\";\n  var APPLY = \"Apply\";\n  var ALT = \"Alt\"; // Various constructors used in interpretation\n\n  var CONS = \"Cons\"; // Cons-list, for stacks\n\n  var RESUME = \"Resume\"; // Continue indiscriminately\n\n  var RELEASE = \"Release\"; // Continue with bracket finalizers\n\n  var FINALIZER = \"Finalizer\"; // A non-interruptible effect\n\n  var FINALIZED = \"Finalized\"; // Marker for finalization\n\n  var FORKED = \"Forked\"; // Reference to a forked fiber, with resumption stack\n\n  var FIBER = \"Fiber\"; // Actual fiber reference\n\n  var THUNK = \"Thunk\"; // Primed effect, ready to invoke\n\n  function Aff(tag, _1, _2, _3) {\n    this.tag = tag;\n    this._1 = _1;\n    this._2 = _2;\n    this._3 = _3;\n  }\n\n  function AffCtr(tag) {\n    var fn = function (_1, _2, _3) {\n      return new Aff(tag, _1, _2, _3);\n    };\n\n    fn.tag = tag;\n    return fn;\n  }\n\n  function nonCanceler(error) {\n    return new Aff(PURE, void 0);\n  }\n\n  function runEff(eff) {\n    try {\n      eff();\n    } catch (error) {\n      setTimeout(function () {\n        throw error;\n      }, 0);\n    }\n  }\n\n  function runSync(left, right, eff) {\n    try {\n      return right(eff());\n    } catch (error) {\n      return left(error);\n    }\n  }\n\n  function runAsync(left, eff, k) {\n    try {\n      return eff(k)();\n    } catch (error) {\n      k(left(error))();\n      return nonCanceler;\n    }\n  }\n\n  var Scheduler = function () {\n    var limit = 1024;\n    var size = 0;\n    var ix = 0;\n    var queue = new Array(limit);\n    var draining = false;\n\n    function drain() {\n      var thunk;\n      draining = true;\n\n      while (size !== 0) {\n        size--;\n        thunk = queue[ix];\n        queue[ix] = void 0;\n        ix = (ix + 1) % limit;\n        thunk();\n      }\n\n      draining = false;\n    }\n\n    return {\n      isDraining: function () {\n        return draining;\n      },\n      enqueue: function (cb) {\n        var i, tmp;\n\n        if (size === limit) {\n          tmp = draining;\n          drain();\n          draining = tmp;\n        }\n\n        queue[(ix + size) % limit] = cb;\n        size++;\n\n        if (!draining) {\n          drain();\n        }\n      }\n    };\n  }();\n\n  function Supervisor(util) {\n    var fibers = {};\n    var fiberId = 0;\n    var count = 0;\n    return {\n      register: function (fiber) {\n        var fid = fiberId++;\n        fiber.onComplete({\n          rethrow: true,\n          handler: function (result) {\n            return function () {\n              count--;\n              delete fibers[fid];\n            };\n          }\n        })();\n        fibers[fid] = fiber;\n        count++;\n      },\n      isEmpty: function () {\n        return count === 0;\n      },\n      killAll: function (killError, cb) {\n        return function () {\n          if (count === 0) {\n            return cb();\n          }\n\n          var killCount = 0;\n          var kills = {};\n\n          function kill(fid) {\n            kills[fid] = fibers[fid].kill(killError, function (result) {\n              return function () {\n                delete kills[fid];\n                killCount--;\n\n                if (util.isLeft(result) && util.fromLeft(result)) {\n                  setTimeout(function () {\n                    throw util.fromLeft(result);\n                  }, 0);\n                }\n\n                if (killCount === 0) {\n                  cb();\n                }\n              };\n            })();\n          }\n\n          for (var k in fibers) {\n            if (fibers.hasOwnProperty(k)) {\n              killCount++;\n              kill(k);\n            }\n          }\n\n          fibers = {};\n          fiberId = 0;\n          count = 0;\n          return function (error) {\n            return new Aff(SYNC, function () {\n              for (var k in kills) {\n                if (kills.hasOwnProperty(k)) {\n                  kills[k]();\n                }\n              }\n            });\n          };\n        };\n      }\n    };\n  } // Fiber state machine\n\n\n  var SUSPENDED = 0; // Suspended, pending a join.\n\n  var CONTINUE = 1; // Interpret the next instruction.\n\n  var STEP_BIND = 2; // Apply the next bind.\n\n  var STEP_RESULT = 3; // Handle potential failure from a result.\n\n  var PENDING = 4; // An async effect is running.\n\n  var RETURN = 5; // The current stack has returned.\n\n  var COMPLETED = 6; // The entire fiber has completed.\n\n  function Fiber(util, supervisor, aff) {\n    // Monotonically increasing tick, increased on each asynchronous turn.\n    var runTick = 0; // The current branch of the state machine.\n\n    var status = SUSPENDED; // The current point of interest for the state machine branch.\n\n    var step = aff; // Successful step\n\n    var fail = null; // Failure step\n\n    var interrupt = null; // Asynchronous interrupt\n    // Stack of continuations for the current fiber.\n\n    var bhead = null;\n    var btail = null; // Stack of attempts and finalizers for error recovery. Every `Cons` is also\n    // tagged with current `interrupt` state. We use this to track which items\n    // should be ignored or evaluated as a result of a kill.\n\n    var attempts = null; // A special state is needed for Bracket, because it cannot be killed. When\n    // we enter a bracket acquisition or finalizer, we increment the counter,\n    // and then decrement once complete.\n\n    var bracketCount = 0; // Each join gets a new id so they can be revoked.\n\n    var joinId = 0;\n    var joins = null;\n    var rethrow = true; // Each invocation of `run` requires a tick. When an asynchronous effect is\n    // resolved, we must check that the local tick coincides with the fiber\n    // tick before resuming. This prevents multiple async continuations from\n    // accidentally resuming the same fiber. A common example may be invoking\n    // the provided callback in `makeAff` more than once, but it may also be an\n    // async effect resuming after the fiber was already cancelled.\n\n    function run(localRunTick) {\n      var tmp, result, attempt;\n\n      while (true) {\n        tmp = null;\n        result = null;\n        attempt = null;\n\n        switch (status) {\n          case STEP_BIND:\n            status = CONTINUE;\n\n            try {\n              step = bhead(step);\n\n              if (btail === null) {\n                bhead = null;\n              } else {\n                bhead = btail._1;\n                btail = btail._2;\n              }\n            } catch (e) {\n              status = RETURN;\n              fail = util.left(e);\n              step = null;\n            }\n\n            break;\n\n          case STEP_RESULT:\n            if (util.isLeft(step)) {\n              status = RETURN;\n              fail = step;\n              step = null;\n            } else if (bhead === null) {\n              status = RETURN;\n            } else {\n              status = STEP_BIND;\n              step = util.fromRight(step);\n            }\n\n            break;\n\n          case CONTINUE:\n            switch (step.tag) {\n              case BIND:\n                if (bhead) {\n                  btail = new Aff(CONS, bhead, btail);\n                }\n\n                bhead = step._2;\n                status = CONTINUE;\n                step = step._1;\n                break;\n\n              case PURE:\n                if (bhead === null) {\n                  status = RETURN;\n                  step = util.right(step._1);\n                } else {\n                  status = STEP_BIND;\n                  step = step._1;\n                }\n\n                break;\n\n              case SYNC:\n                status = STEP_RESULT;\n                step = runSync(util.left, util.right, step._1);\n                break;\n\n              case ASYNC:\n                status = PENDING;\n                step = runAsync(util.left, step._1, function (result) {\n                  return function () {\n                    if (runTick !== localRunTick) {\n                      return;\n                    }\n\n                    runTick++;\n                    Scheduler.enqueue(function () {\n                      // It's possible to interrupt the fiber between enqueuing and\n                      // resuming, so we need to check that the runTick is still\n                      // valid.\n                      if (runTick !== localRunTick + 1) {\n                        return;\n                      }\n\n                      status = STEP_RESULT;\n                      step = result;\n                      run(runTick);\n                    });\n                  };\n                });\n                return;\n\n              case THROW:\n                status = RETURN;\n                fail = util.left(step._1);\n                step = null;\n                break;\n              // Enqueue the Catch so that we can call the error handler later on\n              // in case of an exception.\n\n              case CATCH:\n                if (bhead === null) {\n                  attempts = new Aff(CONS, step, attempts, interrupt);\n                } else {\n                  attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                }\n\n                bhead = null;\n                btail = null;\n                status = CONTINUE;\n                step = step._1;\n                break;\n              // Enqueue the Bracket so that we can call the appropriate handlers\n              // after resource acquisition.\n\n              case BRACKET:\n                bracketCount++;\n\n                if (bhead === null) {\n                  attempts = new Aff(CONS, step, attempts, interrupt);\n                } else {\n                  attempts = new Aff(CONS, step, new Aff(CONS, new Aff(RESUME, bhead, btail), attempts, interrupt), interrupt);\n                }\n\n                bhead = null;\n                btail = null;\n                status = CONTINUE;\n                step = step._1;\n                break;\n\n              case FORK:\n                status = STEP_RESULT;\n                tmp = Fiber(util, supervisor, step._2);\n\n                if (supervisor) {\n                  supervisor.register(tmp);\n                }\n\n                if (step._1) {\n                  tmp.run();\n                }\n\n                step = util.right(tmp);\n                break;\n\n              case SEQ:\n                status = CONTINUE;\n                step = sequential(util, supervisor, step._1);\n                break;\n            }\n\n            break;\n\n          case RETURN:\n            bhead = null;\n            btail = null; // If the current stack has returned, and we have no other stacks to\n            // resume or finalizers to run, the fiber has halted and we can\n            // invoke all join callbacks. Otherwise we need to resume.\n\n            if (attempts === null) {\n              status = COMPLETED;\n              step = interrupt || fail || step;\n            } else {\n              // The interrupt status for the enqueued item.\n              tmp = attempts._3;\n              attempt = attempts._1;\n              attempts = attempts._2;\n\n              switch (attempt.tag) {\n                // We cannot recover from an unmasked interrupt. Otherwise we should\n                // continue stepping, or run the exception handler if an exception\n                // was raised.\n                case CATCH:\n                  // We should compare the interrupt status as well because we\n                  // only want it to apply if there has been an interrupt since\n                  // enqueuing the catch.\n                  if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                    status = RETURN;\n                  } else if (fail) {\n                    status = CONTINUE;\n                    step = attempt._2(util.fromLeft(fail));\n                    fail = null;\n                  }\n\n                  break;\n                // We cannot resume from an unmasked interrupt or exception.\n\n                case RESUME:\n                  // As with Catch, we only want to ignore in the case of an\n                  // interrupt since enqueing the item.\n                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail) {\n                    status = RETURN;\n                  } else {\n                    bhead = attempt._1;\n                    btail = attempt._2;\n                    status = STEP_BIND;\n                    step = util.fromRight(step);\n                  }\n\n                  break;\n                // If we have a bracket, we should enqueue the handlers,\n                // and continue with the success branch only if the fiber has\n                // not been interrupted. If the bracket acquisition failed, we\n                // should not run either.\n\n                case BRACKET:\n                  bracketCount--;\n\n                  if (fail === null) {\n                    result = util.fromRight(step); // We need to enqueue the Release with the same interrupt\n                    // status as the Bracket that is initiating it.\n\n                    attempts = new Aff(CONS, new Aff(RELEASE, attempt._2, result), attempts, tmp); // We should only coninue as long as the interrupt status has not changed or\n                    // we are currently within a non-interruptable finalizer.\n\n                    if (interrupt === tmp || bracketCount > 0) {\n                      status = CONTINUE;\n                      step = attempt._3(result);\n                    }\n                  }\n\n                  break;\n                // Enqueue the appropriate handler. We increase the bracket count\n                // because it should not be cancelled.\n\n                case RELEASE:\n                  attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n                  status = CONTINUE; // It has only been killed if the interrupt status has changed\n                  // since we enqueued the item, and the bracket count is 0. If the\n                  // bracket count is non-zero then we are in a masked state so it's\n                  // impossible to be killed.\n\n                  if (interrupt && interrupt !== tmp && bracketCount === 0) {\n                    step = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);\n                  } else if (fail) {\n                    step = attempt._1.failed(util.fromLeft(fail))(attempt._2);\n                  } else {\n                    step = attempt._1.completed(util.fromRight(step))(attempt._2);\n                  }\n\n                  fail = null;\n                  bracketCount++;\n                  break;\n\n                case FINALIZER:\n                  bracketCount++;\n                  attempts = new Aff(CONS, new Aff(FINALIZED, step, fail), attempts, interrupt);\n                  status = CONTINUE;\n                  step = attempt._1;\n                  break;\n\n                case FINALIZED:\n                  bracketCount--;\n                  status = RETURN;\n                  step = attempt._1;\n                  fail = attempt._2;\n                  break;\n              }\n            }\n\n            break;\n\n          case COMPLETED:\n            for (var k in joins) {\n              if (joins.hasOwnProperty(k)) {\n                rethrow = rethrow && joins[k].rethrow;\n                runEff(joins[k].handler(step));\n              }\n            }\n\n            joins = null; // If we have an interrupt and a fail, then the thread threw while\n            // running finalizers. This should always rethrow in a fresh stack.\n\n            if (interrupt && fail) {\n              setTimeout(function () {\n                throw util.fromLeft(fail);\n              }, 0); // If we have an unhandled exception, and no other fiber has joined\n              // then we need to throw the exception in a fresh stack.\n            } else if (util.isLeft(step) && rethrow) {\n              setTimeout(function () {\n                // Guard on reathrow because a completely synchronous fiber can\n                // still have an observer which was added after-the-fact.\n                if (rethrow) {\n                  throw util.fromLeft(step);\n                }\n              }, 0);\n            }\n\n            return;\n\n          case SUSPENDED:\n            status = CONTINUE;\n            break;\n\n          case PENDING:\n            return;\n        }\n      }\n    }\n\n    function onComplete(join) {\n      return function () {\n        if (status === COMPLETED) {\n          rethrow = rethrow && join.rethrow;\n          join.handler(step)();\n          return function () {};\n        }\n\n        var jid = joinId++;\n        joins = joins || {};\n        joins[jid] = join;\n        return function () {\n          if (joins !== null) {\n            delete joins[jid];\n          }\n        };\n      };\n    }\n\n    function kill(error, cb) {\n      return function () {\n        if (status === COMPLETED) {\n          cb(util.right(void 0))();\n          return function () {};\n        }\n\n        var canceler = onComplete({\n          rethrow: false,\n          handler: function ()\n          /* unused */\n          {\n            return cb(util.right(void 0));\n          }\n        })();\n\n        switch (status) {\n          case SUSPENDED:\n            interrupt = util.left(error);\n            status = COMPLETED;\n            step = interrupt;\n            run(runTick);\n            break;\n\n          case PENDING:\n            if (interrupt === null) {\n              interrupt = util.left(error);\n            }\n\n            if (bracketCount === 0) {\n              if (status === PENDING) {\n                attempts = new Aff(CONS, new Aff(FINALIZER, step(error)), attempts, interrupt);\n              }\n\n              status = RETURN;\n              step = null;\n              fail = null;\n              run(++runTick);\n            }\n\n            break;\n\n          default:\n            if (interrupt === null) {\n              interrupt = util.left(error);\n            }\n\n            if (bracketCount === 0) {\n              status = RETURN;\n              step = null;\n              fail = null;\n            }\n\n        }\n\n        return canceler;\n      };\n    }\n\n    function join(cb) {\n      return function () {\n        var canceler = onComplete({\n          rethrow: false,\n          handler: cb\n        })();\n\n        if (status === SUSPENDED) {\n          run(runTick);\n        }\n\n        return canceler;\n      };\n    }\n\n    return {\n      kill: kill,\n      join: join,\n      onComplete: onComplete,\n      isSuspended: function () {\n        return status === SUSPENDED;\n      },\n      run: function () {\n        if (status === SUSPENDED) {\n          if (!Scheduler.isDraining()) {\n            Scheduler.enqueue(function () {\n              run(runTick);\n            });\n          } else {\n            run(runTick);\n          }\n        }\n      }\n    };\n  }\n\n  function runPar(util, supervisor, par, cb) {\n    // Table of all forked fibers.\n    var fiberId = 0;\n    var fibers = {}; // Table of currently running cancelers, as a product of `Alt` behavior.\n\n    var killId = 0;\n    var kills = {}; // Error used for early cancelation on Alt branches.\n\n    var early = new Error(\"[ParAff] Early exit\"); // Error used to kill the entire tree.\n\n    var interrupt = null; // The root pointer of the tree.\n\n    var root = EMPTY; // Walks a tree, invoking all the cancelers. Returns the table of pending\n    // cancellation fibers.\n\n    function kill(error, par, cb) {\n      var step = par;\n      var head = null;\n      var tail = null;\n      var count = 0;\n      var kills = {};\n      var tmp, kid;\n\n      loop: while (true) {\n        tmp = null;\n\n        switch (step.tag) {\n          case FORKED:\n            if (step._3 === EMPTY) {\n              tmp = fibers[step._1];\n              kills[count++] = tmp.kill(error, function (result) {\n                return function () {\n                  count--;\n\n                  if (count === 0) {\n                    cb(result)();\n                  }\n                };\n              });\n            } // Terminal case.\n\n\n            if (head === null) {\n              break loop;\n            } // Go down the right side of the tree.\n\n\n            step = head._2;\n\n            if (tail === null) {\n              head = null;\n            } else {\n              head = tail._1;\n              tail = tail._2;\n            }\n\n            break;\n\n          case MAP:\n            step = step._2;\n            break;\n\n          case APPLY:\n          case ALT:\n            if (head) {\n              tail = new Aff(CONS, head, tail);\n            }\n\n            head = step;\n            step = step._1;\n            break;\n        }\n      }\n\n      if (count === 0) {\n        cb(util.right(void 0))();\n      } else {\n        // Run the cancelation effects. We alias `count` because it's mutable.\n        kid = 0;\n        tmp = count;\n\n        for (; kid < tmp; kid++) {\n          kills[kid] = kills[kid]();\n        }\n      }\n\n      return kills;\n    } // When a fiber resolves, we need to bubble back up the tree with the\n    // result, computing the applicative nodes.\n\n\n    function join(result, head, tail) {\n      var fail, step, lhs, rhs, tmp, kid;\n\n      if (util.isLeft(result)) {\n        fail = result;\n        step = null;\n      } else {\n        step = result;\n        fail = null;\n      }\n\n      loop: while (true) {\n        lhs = null;\n        rhs = null;\n        tmp = null;\n        kid = null; // We should never continue if the entire tree has been interrupted.\n\n        if (interrupt !== null) {\n          return;\n        } // We've made it all the way to the root of the tree, which means\n        // the tree has fully evaluated.\n\n\n        if (head === null) {\n          cb(fail || step)();\n          return;\n        } // The tree has already been computed, so we shouldn't try to do it\n        // again. This should never happen.\n        // TODO: Remove this?\n\n\n        if (head._3 !== EMPTY) {\n          return;\n        }\n\n        switch (head.tag) {\n          case MAP:\n            if (fail === null) {\n              head._3 = util.right(head._1(util.fromRight(step)));\n              step = head._3;\n            } else {\n              head._3 = fail;\n            }\n\n            break;\n\n          case APPLY:\n            lhs = head._1._3;\n            rhs = head._2._3; // If we have a failure we should kill the other side because we\n            // can't possible yield a result anymore.\n\n            if (fail) {\n              head._3 = fail;\n              tmp = true;\n              kid = killId++;\n              kills[kid] = kill(early, fail === lhs ? head._2 : head._1, function ()\n              /* unused */\n              {\n                return function () {\n                  delete kills[kid];\n\n                  if (tmp) {\n                    tmp = false;\n                  } else if (tail === null) {\n                    join(fail, null, null);\n                  } else {\n                    join(fail, tail._1, tail._2);\n                  }\n                };\n              });\n\n              if (tmp) {\n                tmp = false;\n                return;\n              }\n            } else if (lhs === EMPTY || rhs === EMPTY) {\n              // We can only proceed if both sides have resolved.\n              return;\n            } else {\n              step = util.right(util.fromRight(lhs)(util.fromRight(rhs)));\n              head._3 = step;\n            }\n\n            break;\n\n          case ALT:\n            lhs = head._1._3;\n            rhs = head._2._3; // We can only proceed if both have resolved or we have a success\n\n            if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {\n              return;\n            } // If both sides resolve with an error, we should continue with the\n            // first error\n\n\n            if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {\n              fail = step === lhs ? rhs : lhs;\n              step = null;\n              head._3 = fail;\n            } else {\n              head._3 = step;\n              tmp = true;\n              kid = killId++; // Once a side has resolved, we need to cancel the side that is still\n              // pending before we can continue.\n\n              kills[kid] = kill(early, step === lhs ? head._2 : head._1, function ()\n              /* unused */\n              {\n                return function () {\n                  delete kills[kid];\n\n                  if (tmp) {\n                    tmp = false;\n                  } else if (tail === null) {\n                    join(step, null, null);\n                  } else {\n                    join(step, tail._1, tail._2);\n                  }\n                };\n              });\n\n              if (tmp) {\n                tmp = false;\n                return;\n              }\n            }\n\n            break;\n        }\n\n        if (tail === null) {\n          head = null;\n        } else {\n          head = tail._1;\n          tail = tail._2;\n        }\n      }\n    }\n\n    function resolve(fiber) {\n      return function (result) {\n        return function () {\n          delete fibers[fiber._1];\n          fiber._3 = result;\n          join(result, fiber._2._1, fiber._2._2);\n        };\n      };\n    } // Walks the applicative tree, substituting non-applicative nodes with\n    // `FORKED` nodes. In this tree, all applicative nodes use the `_3` slot\n    // as a mutable slot for memoization. In an unresolved state, the `_3`\n    // slot is `EMPTY`. In the cases of `ALT` and `APPLY`, we always walk\n    // the left side first, because both operations are left-associative. As\n    // we `RETURN` from those branches, we then walk the right side.\n\n\n    function run() {\n      var status = CONTINUE;\n      var step = par;\n      var head = null;\n      var tail = null;\n      var tmp, fid;\n\n      loop: while (true) {\n        tmp = null;\n        fid = null;\n\n        switch (status) {\n          case CONTINUE:\n            switch (step.tag) {\n              case MAP:\n                if (head) {\n                  tail = new Aff(CONS, head, tail);\n                }\n\n                head = new Aff(MAP, step._1, EMPTY, EMPTY);\n                step = step._2;\n                break;\n\n              case APPLY:\n                if (head) {\n                  tail = new Aff(CONS, head, tail);\n                }\n\n                head = new Aff(APPLY, EMPTY, step._2, EMPTY);\n                step = step._1;\n                break;\n\n              case ALT:\n                if (head) {\n                  tail = new Aff(CONS, head, tail);\n                }\n\n                head = new Aff(ALT, EMPTY, step._2, EMPTY);\n                step = step._1;\n                break;\n\n              default:\n                // When we hit a leaf value, we suspend the stack in the `FORKED`.\n                // When the fiber resolves, it can bubble back up the tree.\n                fid = fiberId++;\n                status = RETURN;\n                tmp = step;\n                step = new Aff(FORKED, fid, new Aff(CONS, head, tail), EMPTY);\n                tmp = Fiber(util, supervisor, tmp);\n                tmp.onComplete({\n                  rethrow: false,\n                  handler: resolve(step)\n                })();\n                fibers[fid] = tmp;\n\n                if (supervisor) {\n                  supervisor.register(tmp);\n                }\n\n            }\n\n            break;\n\n          case RETURN:\n            // Terminal case, we are back at the root.\n            if (head === null) {\n              break loop;\n            } // If we are done with the right side, we need to continue down the\n            // left. Otherwise we should continue up the stack.\n\n\n            if (head._1 === EMPTY) {\n              head._1 = step;\n              status = CONTINUE;\n              step = head._2;\n              head._2 = EMPTY;\n            } else {\n              head._2 = step;\n              step = head;\n\n              if (tail === null) {\n                head = null;\n              } else {\n                head = tail._1;\n                tail = tail._2;\n              }\n            }\n\n        }\n      } // Keep a reference to the tree root so it can be cancelled.\n\n\n      root = step;\n\n      for (fid = 0; fid < fiberId; fid++) {\n        fibers[fid].run();\n      }\n    } // Cancels the entire tree. If there are already subtrees being canceled,\n    // we need to first cancel those joins. We will then add fresh joins for\n    // all pending branches including those that were in the process of being\n    // canceled.\n\n\n    function cancel(error, cb) {\n      interrupt = util.left(error);\n      var innerKills;\n\n      for (var kid in kills) {\n        if (kills.hasOwnProperty(kid)) {\n          innerKills = kills[kid];\n\n          for (kid in innerKills) {\n            if (innerKills.hasOwnProperty(kid)) {\n              innerKills[kid]();\n            }\n          }\n        }\n      }\n\n      kills = null;\n      var newKills = kill(error, root, cb);\n      return function (killError) {\n        return new Aff(ASYNC, function (killCb) {\n          return function () {\n            for (var kid in newKills) {\n              if (newKills.hasOwnProperty(kid)) {\n                newKills[kid]();\n              }\n            }\n\n            return nonCanceler;\n          };\n        });\n      };\n    }\n\n    run();\n    return function (killError) {\n      return new Aff(ASYNC, function (killCb) {\n        return function () {\n          return cancel(killError, killCb);\n        };\n      });\n    };\n  }\n\n  function sequential(util, supervisor, par) {\n    return new Aff(ASYNC, function (cb) {\n      return function () {\n        return runPar(util, supervisor, par, cb);\n      };\n    });\n  }\n\n  Aff.EMPTY = EMPTY;\n  Aff.Pure = AffCtr(PURE);\n  Aff.Throw = AffCtr(THROW);\n  Aff.Catch = AffCtr(CATCH);\n  Aff.Sync = AffCtr(SYNC);\n  Aff.Async = AffCtr(ASYNC);\n  Aff.Bind = AffCtr(BIND);\n  Aff.Bracket = AffCtr(BRACKET);\n  Aff.Fork = AffCtr(FORK);\n  Aff.Seq = AffCtr(SEQ);\n  Aff.ParMap = AffCtr(MAP);\n  Aff.ParApply = AffCtr(APPLY);\n  Aff.ParAlt = AffCtr(ALT);\n  Aff.Fiber = Fiber;\n  Aff.Supervisor = Supervisor;\n  Aff.Scheduler = Scheduler;\n  Aff.nonCanceler = nonCanceler;\n  return Aff;\n}();\n\nexports._pure = Aff.Pure;\nexports._throwError = Aff.Throw;\n\nexports._catchError = function (aff) {\n  return function (k) {\n    return Aff.Catch(aff, k);\n  };\n};\n\nexports._map = function (f) {\n  return function (aff) {\n    if (aff.tag === Aff.Pure.tag) {\n      return Aff.Pure(f(aff._1));\n    } else {\n      return Aff.Bind(aff, function (value) {\n        return Aff.Pure(f(value));\n      });\n    }\n  };\n};\n\nexports._bind = function (aff) {\n  return function (k) {\n    return Aff.Bind(aff, k);\n  };\n};\n\nexports._liftEffect = Aff.Sync;\nexports.makeAff = Aff.Async;\n\nexports._makeFiber = function (util, aff) {\n  return function () {\n    return Aff.Fiber(util, null, aff);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}